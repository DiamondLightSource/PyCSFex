"""WIP - AB - Oct 2020"""import syssys.path.append("..")from general_crystals import CrystalFactoryfrom general_crystals.Si_Origin2_isodwf import Si_isodwffrom Structure_Factor_Calculator.diffraction_environment import Diff_Environmentfrom Structure_Factor_Calculator.structure_factor_calc import Structure_Factorimport timeimport numpy as npimport matplotlib.pyplot as pltfrom Structure_Factor_Calculator.xrpy import atom# define some variables at the top so they become globals - acessible in all functionsplot_title_string = "None"verbosity = 2crystal_type = "silicon"def edge_name(ie) :    abNames= ['K ','L1','L2','L3','M1','M2','M3','M4','M5','N1',              'N2','N3','N4','N5']    return abNames[ie]# for a given fractional deviation from the backscattering energy of epsilon = dE/E find the reflectivitydef backscattering_reflectivity(F,Fbar,F0,gamma,epsilon):    eta = (F0 - 2*epsilon/gamma) / np.sqrt(F*Fbar)    rp = (abs(eta + np.sqrt(eta**2-1.)))**2 * abs(F) / abs(Fbar)    rm = (abs(eta - np.sqrt(eta**2-1.)))**2 * abs(F) / abs(Fbar)    bxr = min(rp,rm)    return bxr# determines the pk value, width and integrated refletivity in backscattering from the calculated rocking curvedef backscattering_details(F,Fbar,F0,gamma,ekeV):    n = 301; ndw = 3  # number of pts spread over 2*ndw darwin widths    dw =  gamma * abs(F)  # basically the darwin width    cen = gamma * F0.real / 2    epmin = cen - 3*dw ;   epmax = cen + 3*dw ;  de = (epmax-epmin)/(n-1)    earray = []; rarray = []; integrated_reflectivity = 0.; meVarray =[]    for i in range(n):        ee = epmin + i*de        earray.append(float(ee))        meVarray.append(float(ee*1.e6*ekeV))        rr= float(backscattering_reflectivity(F,Fbar,F0,gamma,ee))        rarray.append(rr)        integrated_reflectivity = integrated_reflectivity + rr    integrated_reflectivity = integrated_reflectivity * de    fr = 0.5    [clear_peak,xpk,ypk,xlow,xhgh] = peak(earray,rarray,fr)    fwhm = xhgh-xlow    ts = "%.3f keV" %(ekeV)    plt.grid(True)    plt.ylim(0,1)    plt.xlabel("Energy Shift [meV]")    plt.ylabel("Reflectivity")    plt.title(plot_title_string)    plt.plot(meVarray,rarray)    plt.pause(0.01)    return ypk,fwhm,integrated_reflectivity# processes the peak of a spectrum to find, eg.g the fwhmdef peak(x,y,fr):   # returns the peak position and the full width at fr of ymax    clear_peak = False    ypk = np.max(y)    if (len(x) != len(y)):        sys.exit("length of x and y arrays not the same")    if (fr>.999 or fr<0) :        print("fr = %g out of range in peak" %(fr))    im = np.argmax(y)    xpk = x[im]    frpk = fr*ypk    xlow = x[0]; xhgh=x[len(x)-1]#print("xpk ypk frpk xlow xhgh",xpk,ypk,frpk,xlow,xhgh)    for i in range(im-1,0,-1):        if (y[i]<frpk and y[i+1]>=frpk):            slope = ( (y[i+1]-y[i]) / (x[i+1]-x[i]) )            dx = (frpk-y[i])/slope            xlow = x[i]+dx            break    for i in range(im,len(x)-1):        if (y[i]>frpk and y[i+1]<=frpk):            slope = ( (y[i+1]-y[i]) / (x[i+1]-x[i]) )            dx = (frpk-y[i])/slope            xhgh = x[i]+dx            break    if ((xlow-x[0])>0. and (xhgh-x[len(x)-1])<0) : clear_peak = True#print("clear peak:",clear_peak,"  xlow = %3g xhgh=%3g   xhgh-xlow =%3g" %(xlow,xhgh,xhgh-xlow))    return clear_peak,xpk,ypk,xlow,xhghdef get_possible_backreflections(crystal_type,ekeV=10.,tmin=20.,tmax=600.,Rmin=0.1):    """        an involved function that returns all backreflections in some range for a material        "_rl" is short for "_reflist"    """    dfd_tol = 1.e-8   # get d to fractional tolerance dfd_tol    ffd_tol = 0.03     # assume reflections with F differing by < ffd_tol are essentially the same    fmin_tol = 0.001    energy_eV = ekeV*1000    d_desired = 12.39842/ekeV/2.    element_list = crystal_type.element_list    crystal_family = crystal_type.crystal_system    refatom_coords = crystal_type.refatom_coords    hklInit = crystal_type.environment.hkl    parameters1 = crystal_type.lattice_unit_cell_params(tmin)    parameters2 = crystal_type.lattice_unit_cell_params(tmax)    if (verbosity>1):        print("Finding back reflections in %s (%d<T[K]<%d) at %.4f keV (d=%8g) with reflectivity > %.2f " %(crystal_type.description,tmin,tmax,ekeV,d_desired,Rmin))    # get range of hkl values to test    plane=[1,0,0] ; da = Diff_Environment.d_hkl(parameters2,plane,crystal_family)    plane=[0,1,0] ; db = Diff_Environment.d_hkl(parameters2,plane,crystal_family)    plane=[0,0,1] ; dc = Diff_Environment.d_hkl(parameters2,plane,crystal_family)    hmax = 1 + int(da/d_desired)    kmax = 1 + int(db/d_desired)    lmax = 1 + int(dc/d_desired)    if (verbosity>20) : print("hmax,kmax,lmax",hmax,kmax,lmax)# find t and d for possible reflections    hkl_rl = [] ;   t_rl = [] ;  d_rl = []; refforsort = []; nfound=0;  ntested=0    time1 = time.process_time()    for ih in range(-hmax,hmax+1):        for ik in range(-kmax,kmax+1):            for il in range(-lmax,lmax+1):                hkl_abs_sum = abs(ih) + abs(ik) + abs(il)                if (hkl_abs_sum>0):                    ntested=ntested+1                    plane = [ih,ik,il]                    d1 = Diff_Environment.d_hkl(parameters1,plane,crystal_family)                    d2 = Diff_Environment.d_hkl(parameters2,plane,crystal_family)                    if ((d_desired>d1) and (d_desired<d2)):                        nfound = nfound+1                        t1 = tmin; t2 = tmax                        dsl = (d2-d1) / (t2-t1) ;  t_est = t1 + (d_desired - d1) / dsl                        parameters = crystal_type.lattice_unit_cell_params(t_est)                        d_est = Diff_Environment.d_hkl(parameters,plane,crystal_family)                        dfd = abs((d_desired-d_est)/d_desired)                        iloop = 0; ilm = 100                        while (dfd>dfd_tol and iloop<ilm):                            iloop = iloop+1                            if (d_est>d_desired):                                t2 = t_est; d2 = d_est                            else:                                t1 = t_est; d1 = d_est                            dsl = (d2-d1) / (t2-t1) ;  t_est = t1 + (d_desired - d1) / dsl                            parameters = crystal_type.lattice_unit_cell_params(t_est)                            d_est = Diff_Environment.d_hkl(parameters,plane,crystal_family)                            dfd = abs((d_desired-d_est)/d_desired)                        hkl_rl.append([ih,ik,il])                        t_rl.append(t_est)                        d_rl.append(d_est)                        if (iloop>(ilm-2)) : print("iloop maxed out finding d. fract diff %2e" %(dfd))                        refforsort.append([[ih,ik,il],t_est,d_est])    refforsort.sort(key = lambda refl: refl[1])    hklsort = []; tsort = []; dsort = []    for ir in range(len(refforsort)):        hklsort.append(refforsort[ir][0])        tsort.append(refforsort[ir][1])        dsort.append(refforsort[ir][2])    time2 = time.process_time()    nref=len(refforsort)    ndistinct=0    if (verbosity>1):        print("   Found %d possible refs of %d tested at tol %3g in %.6f s" %(nref,ntested,dfd_tol,time2-time1))    if (nref<1) : return nref,ndistinct    #   now get structure factors, widths, reflectivities#   checks if (-h -k -l) already calculated and the use those F's (F<->Fbar, of course)    time1 = time.process_time()    F_rl = [];  Fbar_rl=[];   F0_rl=[];   rpk_rl = [];  dwmeV_rl = [];  fwhmmeV_rl = []    mkpermeV_rl = []    n_sfc = 0    t_tol = 0.1    for ir in range(len(refforsort)):        plane = hklsort[ir]        plane_bar = [-plane[0],-plane[1],-plane[2]]        temperature_K = tsort[ir]        drefl_A = dsort[ir]        parameters = crystal_type.lattice_unit_cell_params(temperature_K)        angle_plane_wavelength = (np.pi/2., plane, 2*d_desired)        # get local thermal expansion for this reflection        d1 = Diff_Environment.d_hkl(parameters,plane,crystal_family)        t1 = temperature_K        t2 = temperature_K + 1.        if (t2>tmax) : t2 = t2-2.        parameters2 = crystal_type.lattice_unit_cell_params(t2)        d2 = Diff_Environment.d_hkl(parameters2,plane,crystal_family)        e1 = 12.39842 / (2.*d1) ; e2 = 12.39842 / (2.*d2); de_meV = (e2-e1)*1.e6        e_desired_eV = 1000*12.39842 / (2.*d_desired)        mkpermeV_rl.append(1000.*(t2-t1)/de_meV)                # avoid duplicating calculations for bar reflections        try:            idx = hklsort.index(plane_bar)        except ValueError:            print("Did not find reflection -h,-k,-l in reflist but should be there!",idx,plane_bar)            break        if (idx <= ir):            #print("Found reflection ",plane_bar," already calculated at ",idx )            F = Fbar_rl[idx] ;  Fbar = F_rl[idx] ; F0 = F0_rl[idx]        else:            if ( (ir == 0) or ( tsort[ir] - tsort[ir-1] > t_tol ) ):                crystal_type.set_temp_miller_energy(temperature_K,plane,e_desired_eV)            else:                crystal_type.set_miller_energy(plane,e_desired_eV)            F_list = Structure_Factor.F_hkl(crystal_type,crystal_type.environment)            F = F_list[0];  Fbar = F_list[1]; F0 = F_list[2]            n_sfc=n_sfc+1        re = 2.81794e-5        V_A3 = Diff_Environment.cell_volume(parameters)        bc_gamma = re * (2.*drefl_A)**2 / np.pi / V_A3   # gamma as defined in batterman and cole rmp 1964        e_cen = bc_gamma * F0.real / 2        rcen = backscattering_reflectivity(F,Fbar,F0,bc_gamma,e_cen)        [rpk, fwhm, integrated_reflectivity] = backscattering_details(F,Fbar,F0,bc_gamma,ekeV)        fbw = bc_gamma * abs(F)        F_rl.append(F)        Fbar_rl.append(Fbar)        F0_rl.append(F0)        rpk_rl.append(rpk)        dwmeV_rl.append(ekeV*fbw*1e6)        fwhmmeV_rl.append(ekeV*fwhm*1e6)        if (verbosity>50) :            print("%3d  (%3d %3d %3d) " %(ir,angle_plane_wavelength[1][0],angle_plane_wavelength[1][1],angle_plane_wavelength[1][2]),"%6.2fK " %(temperature_K)," F=(%7.3f,%7.3f) Fbar=(%7.3f,%7.3f) ||=%7.3f,%7.3f   Rcen=%3.2f  Rpk=%3.2f   DW_meV=%6.2f  FWHM_meV=%6.2f" %(F.real,F.imag,Fbar.real,Fbar.imag,abs(F),abs(Fbar),rcen,rpk,ekeV*fbw*1e6,ekeV*fwhm*1e6))    time2 = time.process_time()    if (verbosity>1):        print("   Calculated all structure factors (%d calls to F_hkl) in %.3f s " %(n_sfc,time2-time1))    # remove reflections with small reflectivity    nremoved = 0    while(min(rpk_rl)<Rmin):        mindex = rpk_rl.index(min(rpk_rl))        nremoved = nremoved+1        hklsort.pop(mindex)        tsort.pop(mindex)        F_rl.pop(mindex)        Fbar_rl.pop(mindex)        F0_rl.pop(mindex)        rpk_rl.pop(mindex)        dwmeV_rl.pop(mindex)        fwhmmeV_rl.pop(mindex)        mkpermeV_rl.pop(mindex)    nref = len(hklsort)    if (verbosity>1):        if (nremoved>0) :            print("   Removed %d reflections with reflectivity < %.3f leaving %d" %(nremoved,Rmin,nref))        else :            print("   All found to have reflectivity > %.3f" %(Rmin))        if (nref>0) :            print("   T-Range: %d to %d K    Pk_Reflectivity: %.3f to %.3f   FWHM: %.1f to %.1f meV" %(min(t_rl),max(t_rl),min(rpk_rl),max(rpk_rl),min(fwhmmeV_rl),max(fwhmmeV_rl)))    # get multiplicities and redundancies based on specific tolerances    t_tol = 0.1   # tolerance on T difference K    r_tol = 0.02  # maximum change in fractional reflectivity (diff/average) reflectivity    bw_tol= 0.03  # maximum change in fractional bandwidth (diff/average) reflectivity    multiplicity_rl = [] ; redundant_rl = []    for ir1 in range(nref) :        redundant_rl.append(False)        multiplicity_rl.append(0)        for ir2 in range(nref) :            t_diff = abs(tsort[ir1]-tsort[ir2])            r_diff = abs( (rpk_rl[ir1]-rpk_rl[ir2]) / ((rpk_rl[ir1]+rpk_rl[ir2])/2.))            bw_diff =abs( (fwhmmeV_rl[ir1]-fwhmmeV_rl[ir2]) / ((fwhmmeV_rl[ir1]+fwhmmeV_rl[ir2])/2.))            if (t_diff < t_tol  and  r_diff < r_tol and bw_diff < bw_tol) :                multiplicity_rl[ir1] +=1                if (ir2<ir1) : redundant_rl[ir1] = True    ndistinct = redundant_rl.count(False)    if (ndistinct<nref and verbosity>1):        print("   Found %d distinct reflection(s) using tol of %gK and fractional tolerances of %.3f and %.3f on peak reflectivity and bandwidth" %(ndistinct,t_tol,r_tol,bw_tol))    if (verbosity>=1) :        for ir in range(nref):            if(redundant_rl[ir]==False) :                print("     %3d  (%3d %3d %3d) %3d  " %(ir,hklsort[ir][0],hklsort[ir][1],hklsort[ir][2],multiplicity_rl[ir]),"%4dK " %(tsort[ir]),"  Rpk=%3.2f   FWHM_meV=%6.2f    mk/meV=%6.1f" %(rpk_rl[ir],fwhmmeV_rl[ir],mkpermeV_rl[ir]))    return nref,ndistinct,ekeV,hkl_rl,t_rl,F_rl,Fbar_rl,F0_rl,rpk_rl,dwmeV_rl,fwhmmeV_rl,mkpermeV_rl,redundant_rl,multiplicity_rlverbosity = 100  # 0=min, 1=usual, 2=slightlyverbose, higher for debug# choose either an energy or and elementen = 10.0TInit_K = 300hklInit = [1,1,1]SiIso = Si_isodwf(TInit_K,hklInit,en*1000)while (True):    ens = input("\nEnergy in [keV] or element symbol (return to skip): ")    if (ens=="") : break    try:        en = float(ens)        if (en<0.1) : break        plt.clf()        plot_title_string = "Backreflections at %.4f keV in %s" %(en,crystal_type)        get_possible_backreflections( SiIso, ekeV=en )    except ValueError:        try:            verbosity = 11            [iz,symbol,elName] = atom.element(ens)            ad = atom.atomData(iz)            nedges = min(len(ad[3]),14)   # only look at first 14 (named) edges....            print("\n%2s (Z=%2d) has %2d edges." %(symbol,iz,nedges))            for iedge in range(nedges) :                en = float(ad[3][iedge])                plt.clf()                plot_title_string = "%2s %s edge at %.4f keV in silicon " %(symbol,edge_name(iedge),en)                print(iedge+1,' ',plot_title_string,end='')                if (en<=30.) :                    rrr = get_possible_backreflections( SiIso, ekeV=en )                    #if (rrr[0]>0) : ens = input("     Press return to continue")                    print("-> %d distinct reflections" %(rrr[1]))                else :                    print("-> Will not calculate silicon above 30 keV!")        except ValueError:            breakemin = 5.0 ; emax = 12.0print("\n\nConsidering all edges from %.4f to %.4f keV...\n" %(emin,emax))for iz in range(1,93):    ad = atom.atomData(iz)    [ized_chk,symbol,elName] = atom.element(iz)    nedges = len(ad[3])    print("\n%2s (Z=%2d) has %2d edges." %(symbol,iz,nedges))    for iedge in range(nedges) :        en = float(ad[3][iedge])        plt.clf()        if (en>=emin and en<=emax) :            plot_title_string = "%2s %s edge at %.4f keV in silicon" %(symbol,edge_name(iedge),en)            print(plot_title_string)            rrr = get_possible_backreflections( SiIso, ekeV=en )#            if (rrr[0]>0) : ens = input("     Press return to continue")